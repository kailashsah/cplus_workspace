#include <iostream>
using namespace std;
/*
	1. When required to use move constructor
	
	2. Move constructor follows similar guidelines as copy constructors. It is required when your class holds members by pointer or other fragile data fields (sockets, db connections etc), so that automatically generated one would possibly mess up the memory layout by deleting the same object twice. So if you don't have any pointer fields, you don't have to write move constructor.

	3. The default move constructor and move assignment generated by the compiler will call move constructor/asignment for each member of the class.

		If your class has only raw members, "char * buffer" for example, you have to write your own move operations.

		If your class has only "managed members", "vector" for example, default move operations for you class will be ok because it delegates the operation to each member.

		If your class has "managed members" mixed with "raw members", vector and int* for example, your movement operations will have to do the manual move of raw resources and call move operations for managed objects:

	4. ex

		A(const A&& a)
		{
			printf("a = %p,b = %p,c = %p\n", &(a.a), &(a.b), a.c);
			this->b = move(a.b);
			this->a = move(a.a);
			this->c = move(a.c);
			cout<<"Move constructor\n";
			printf("a = %p,b = %p,c = %p\n", &a, &b, &c);
		}

	5. C++ Move Semantics to Manage Pointers to Externally Allocated Memory
		use unique_ptr<>
		
*/